<!DOCTYPE html>
<html dir="ltr" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0" />
    <title>Stencil Component Starter</title>

    <script type="module" src="/build/jeep-sqlite.esm.js"></script>
    <script nomodule src="/build/jeep-sqlite.js"></script>
  </head>
  <style>
    /* Navbar container */
    .navbar {
      overflow: hidden;
      background-color: #333;
      font-family: Arial;
    }

    /* Links inside the navbar */
    .navbar a {
      float: left;
      font-size: 16px;
      color: white;
      text-align: center;
      padding: 14px 16px;
      text-decoration: none;
    }

    /* The dropdown container */
    .dropdown {
      float: left;
      overflow: hidden;
    }

    /* Dropdown button */
    .dropdown .dropbtn {
      font-size: 16px;
      border: none;
      outline: none;
      color: white;
      padding: 14px 16px;
      background-color: inherit;
      font-family: inherit; /* Important for vertical align on mobile phones */
      margin: 0; /* Important for vertical align on mobile phones */
    }

    /* Add a red background color to navbar links on hover */
    .navbar a:hover, .dropdown:hover .dropbtn {
      background-color: red;
    }

    /* Dropdown content (hidden by default) */
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #f9f9f9;
      min-width: 160px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1;
    }

    /* Links inside the dropdown */
    .dropdown-content a {
      float: none;
      color: black;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      text-align: left;
    }

    /* Add a grey background color to dropdown links on hover */
    .dropdown-content a:hover {
      background-color: #ddd;
    }

    /* Show the dropdown menu on hover */
    .dropdown:hover .dropdown-content {
      display: block;
    }
    .container {
      margin-left: 25px;
    }
  </style>
  <body>
    <div class="navbar">
      <a href="index.html">Home</a>
      <div class="dropdown">
        <button class="dropbtn">Tests
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="index_delete.html">Delete Tests Page</a>
          <a href="index_deleteFKC.html">Delete FKC Tests Page</a>
          <a href="index_page1_issue11.html">Page 1 Issue11 Tests Page</a>
          <a href="index_page2_issue11.html">Page 2 Issue11 Tests Page</a>
          <a href="index_incremental_upgrade_version.html">New Incremental Upgrade Version</a>
          <a href="index_readonly.html">DB Readonly</a>
          <a href="index_getFromHTTP.html">DB Get FROM HTTP Request</a>
          <a href="index_concurrent.html">DB Concurrent Test</a>
          <a href="index_issue385.html">Issue#385 Test</a>
          <a href="index_getFromLocalDiskToStore.html">DB Get FROM Local Disk to Store</a>
          <a href="index_returning.html">DB Test RETURNING</a>
          <a href="index_issue445.html">DB Test issue445</a>
          <a href="index_transaction.html">DB Test Transactions</a>
        </div>
      </div>
    </div>
    <h1>Home Page</h1>
    <div class="container">
      <h2 class="message"></h2>
    </div>
    <jeep-sqlite autoSave></jeep-sqlite>
</body>
</html>
<script>
  (async () => {
    const messageEl = document.querySelector('.message');
    await customElements.whenDefined('jeep-sqlite');
    const jeepSqlite = document.querySelector('jeep-sqlite');
    jeepSqlite.addEventListener('jeepSqliteImportProgress', (event) => {
      console.log(`Import: ${event.detail.progress}`)
    });
    jeepSqlite.addEventListener('jeepSqliteExportProgress', event => {
      console.log(`Export: ${event.detail.progress}`)
    });
    let echo = await jeepSqlite.echo({value:"Hello World from Jeep"});
    if(await jeepSqlite.isStoreOpen()) {
        try {

          // *** test all basic methods

          await jeepSqlite.createConnection({
                    database:"testNew",
                    version: 1
                });
            // open db testNew
            await jeepSqlite.open({database: "testNew"});
            const isDB = await jeepSqlite.isDBOpen({database: "testNew"})

            let sql = `-- Redefine Table users
              CREATE TABLE IF NOT EXISTS users (
                /*
                 * Author: Jeepq
                 * Purpose: To show a comment that spans multiple lines in your SQL
                 * statement in SQLite.
                 */
                id INTEGER PRIMARY KEY NOT NULL,
                email TEXT UNIQUE NOT NULL,
                name TEXT,company TEXT,
                size REAL,
                age INTEGER,
                sql_deleted BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1)),
                last_modified INTEGER DEFAULT (strftime('%s', 'now'))
              );
              CREATE INDEX IF NOT EXISTS users_index_name ON users (name);
              CREATE INDEX IF NOT EXISTS users_index_last_modified ON users (last_modified);
              CREATE TRIGGER IF NOT EXISTS users_trigger_last_modified AFTER UPDATE ON users
                FOR EACH ROW WHEN NEW.last_modified < OLD.last_modified
                BEGIN UPDATE users SET last_modified = (strftime('%s', 'now')) WHERE id=OLD.id;
                END;
              PRAGMA user_version = 1;
            `;
            console.log(`sql: ${sql}`);
            let ret = await jeepSqlite.execute({database: "testNew", statements: sql});
            ret = await jeepSqlite.isTableExists({database: "testNew", table: "users"});
            ret = await jeepSqlite.isTableExists({database: "testNew", table: "contact"});
            // create synchronization table
            ret = await jeepSqlite.createSyncTable({database: "testNew"});
            // set the synchronization date
            let syncDate = "2021-08-01T08:42:25.000Z";
            await jeepSqlite.setSyncDate({database: "testNew", syncdate: syncDate});
            // get the synchronization date
            ret = await jeepSqlite.getSyncDate({database: "testNew"});
            if(ret.syncDate !== 1627807345) {
              throw new Error("Get the synchronization date failed");
            }
            // Insert some Users
            const row = [["Whiteley","Whiteley.com",30,1.83],["Jones","Jones.com",44,1.75]];
            let delUsers = `DELETE FROM users;`;
            delUsers += `VACUUM;`;
            ret = await jeepSqlite.execute({database: "testNew", statements: delUsers, transaction: false});
            let twoUsers = `INSERT INTO users (name,email,age,size) VALUES ("${row[0][0]}","${row[0][1]}",${row[0][2]},${row[0][3]});`;
            twoUsers += `INSERT INTO users (name,email,age,size) VALUES ("${row[1][0]}","${row[1][1]}",${row[1][2]},${row[1][3]});`;
            ret = await jeepSqlite.execute({database: "testNew", statements: twoUsers});
            if (ret.changes.changes !== 2) {
              throw new Error("Execute 3 users failed");
            }
            // Save Database to store
            await jeepSqlite.saveToStore({database: "testNew"});
            // Select all users
            ret = await jeepSqlite.query({database: "testNew",
                                          statement: "SELECT * FROM users;"});
            // Select users where size > 1.80
            ret = await jeepSqlite.query({database: "testNew",
                                          statement: "SELECT * FROM users where size > ?;",
                                          values:[1.80]});
            // add one user with statement and values
            let sqlcmd = "INSERT INTO users (name,email,age,size,company) VALUES (?,?,?,?,?)";
            let values = ["Simpson","Simpson@example.com",69,1.82,null];
            ret = await jeepSqlite.run({database: "testNew",
                                          statement: sqlcmd,
                                          values: values});
            if(ret.changes.lastId !== 3) {
              throw new Error("Run 1 user failed");
            }
            // add one user with statement
            sqlcmd = `INSERT INTO users (name,email,age,size,company) VALUES ` +
                              `("Brown","Brown@example.com",15,1.75,null)`;
            ret = await jeepSqlite.run({database: "testNew",
                        statement: sqlcmd});
            if(ret.changes.lastId !== 4) {
              throw new Error("Run 2 user failed");
            }
            // Select all users
            ret = await jeepSqlite.query({database: "testNew",
                                          statement: "SELECT * FROM users;"});
            if(ret.values.length != 4) {
              throw new Error("Query 3 user failed");
            }
            ret = await jeepSqlite.getVersion({database: "testNew"});

            // *** test ExecuteSet
            await jeepSqlite.createConnection({
                    database:"testSet",
                    version: 1
            });
            ret = await jeepSqlite.isDBExists({database:"testSet"});
            if (ret.result) {
              await jeepSqlite.deleteDatabase({database:"testSet"});
            }
            const createSchemaContacts = `
              CREATE TABLE IF NOT EXISTS contacts (
                id INTEGER PRIMARY KEY NOT NULL,
                email TEXT UNIQUE NOT NULL,
                name TEXT,
                FirstName TEXT,
                company TEXT,
                size REAL,
                age INTEGER,
                MobileNumber TEXT
              );
              CREATE INDEX IF NOT EXISTS contacts_index_name ON contacts (name);
              CREATE INDEX IF NOT EXISTS contacts_index_email ON contacts (email);
              PRAGMA user_version = 1;
            `;
            // open db testSet
            await jeepSqlite.open({database: "testSet"});
            const isDBSet = await jeepSqlite.isDBOpen({database: "testSet"})
            const setContacts = [
              { statement:"INSERT INTO contacts (name,FirstName,email,company,age,MobileNumber) VALUES (?,?,?,?,?,?);",
                values:["Simpson","Tom","Simpson@example.com",null,69,"4405060708"]
              },
              { statement:"INSERT INTO contacts (name,FirstName,email,company,age,MobileNumber) VALUES (?,?,?,?,?,?);",
                values:[
                  ["Jones","David","Jones@example.com",,42.1,"4404030201"],
                  ["Whiteley","Dave","Whiteley@example.com",,45.3,"4405162732"],
                  ["Brown","John","Brown@example.com",null,35,"4405243853"]
                ]
              },
              { statement:"UPDATE contacts SET age = ? , MobileNumber = ? WHERE id = ?;",
                values:[51.4,"4404030202",2]
              }
            ];
            const setIssue170 = [
              { statement: "DROP TABLE IF EXISTS issue170", values: [] },
              { statement: "CREATE TABLE issue170 (src VARCHAR(255))", values: [] },
              { statement: "INSERT INTO issue170 (src) values (?)", values: ["google.com"] },
            ]
            // Create testSet schema
            ret = await jeepSqlite.execute({database: "testSet", statements: createSchemaContacts});
            // Create testSet contact
            ret = await jeepSqlite.executeSet({database: "testSet", set: setContacts});
            if (ret.changes.changes !== 5) {
              throw new Error("ExecuteSet 5 contacts failed");
            }
            // test issue #378
            const upstmt = 'UPDATE contacts SET age = ? WHERE id = ?';
            ret = await jeepSqlite.run({database: "testSet", statement: upstmt, values: [31.2,3], readonly: false});
            console.log(`&&&& ret: ${JSON.stringify(ret)} &&&&`);
            if (ret.changes.changes !== 1) {
              throw new Error("Run Update issue378 failed");
            }

            ret = await jeepSqlite.executeSet({database: "testSet", set: setIssue170});
            if (ret.changes.changes !== 1) {
              throw new Error("ExecuteSet 6 issue170 failed");
            }
            // Select all users
            ret = await jeepSqlite.query({database: "testSet",
                                          statement: "SELECT * FROM issue170;"});
            if(ret.values.length !== 1 || ret.values[0].src !== "google.com") {
              throw new Error("Query issue170 failed");
            }

            // *** test Import from Json
            const dataToImport = {
              database : "db-from-json",
              version : 1,
              encrypted : false,
              mode : "full",
              tables :[
                {
                  name: "users",
                  schema: [
                      {column:"id", value: "INTEGER PRIMARY KEY NOT NULL"},
                      {column:"email", value:"TEXT UNIQUE NOT NULL"},
                      {column:"name", value:"TEXT"},
                      {column:"age", value:"REAL"},
                      {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                      {column:"last_modified", value:"INTEGER"}
                  ],
                  indexes: [
                      {name: "index_user_on_name",value: "name"},
                      {name: "index_user_on_last_modified",value: "last_modified DESC"},
                      {name: "index_user_on_email_name", value: "email ASC, name", mode: "unique"}
                  ],
                  values: [
                      [1,"Whiteley.com","Whiteley",30.5,0,1582536810],
                      [2,"Jones.com","Jones",44.2,0,1582812800],
                      [3,"Simpson@example.com","Simpson",69,0,1583570630],
                      [4,"Brown@example.com","Brown",15,0,1590383895]
                  ]
                },
                {
                  name: "messages",
                  schema: [
                    {column:"id", value: "INTEGER PRIMARY KEY NOT NULL"},
                    {column:"title", value:"TEXT NOT NULL"},
                    {column:"body", value:"TEXT NOT NULL"},
                    {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                    {column:"last_modified", value:"INTEGER"}
                  ],
                  values: [
                      [1,"test post 1","content test post 1",0,1587310030],
                      [2,"test post 2","content test post 2",0,1590388125]
                  ]
                },
              ]
            };
            // test Json object validity
            let result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(dataToImport)});
            if(!result.result) {
              throw new Error("IsJsonValid failed");
            }
            // full import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(dataToImport)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'full' dataToImport failed");
            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-from-json", version: 1});
            // open db testNew
            await jeepSqlite.open({database: "db-from-json"});
            let isDBJson = await jeepSqlite.isDBOpen({database: "db-from-json"})
            if (!isDBJson.result) throw new Error("isDBOpen 'db-from-json' failed");
            // get Table's list
            ret = await jeepSqlite.getTableList({database: "db-from-json"});
            console.log(`&&&& table List: ${JSON.stringify(ret)}`)
            // create synchronization table
            ret = await jeepSqlite.createSyncTable({database: "db-from-json"});
            if (result.changes.changes < 0) throw new Error("CreateSyncTable failed");
            ret = await jeepSqlite.getSyncDate({database: "db-from-json"});
            if(ret.length === 0) throw new Error("GetSyncDate failed");
            // get Table's list
            ret = await jeepSqlite.getTableList({database: "db-from-json"});
            if(ret.values.length !== 2 ||
                    ret.values[0] !== "messages" ||
                    ret.values[1] !== "users") {
              throw new Error("GetTableList db-from-json failed");
            }
            // Select all users
            ret = await jeepSqlite.query({database: "db-from-json",
                                          statement: "SELECT * FROM users;"});
            if(ret.values.length !== 4 ||
                  ret.values[0].name !== "Whiteley" ||
                  ret.values[1].name !== "Jones" ||
                  ret.values[2].name !== "Simpson" ||
                  ret.values[3].name !== "Brown"  ) {
              throw new Error("Query 1 db-from-json Users failed");
            }
            await jeepSqlite.closeConnection({database:"db-from-json"});

            // modify the schema of db-from-json and create version 2
            const dataToImportV2 = {
              database : "db-from-json",
              version : 2,
              encrypted : false,
              mode : "full",
              tables :[
                {
                  name: "users",
                  schema: [
                      {column:"id", value: "INTEGER PRIMARY KEY NOT NULL"},
                      {column:"email", value:"TEXT UNIQUE NOT NULL"},
                      {column:"name", value:"TEXT"},
                      {column:"age", value:"INTEGER"},
                      {column:"size", value:"REAL"},
                      {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                      {column:"last_modified", value:"INTEGER"}
                  ],
                  indexes: [
                      {name: "index_user_on_name",value: "name"},
                      {name: "index_user_on_last_modified",value: "last_modified DESC"},
                      {name: "index_user_on_email_name", value: "email ASC, name", mode: "unique"}
                  ],
                  values: [
                      [1,"Whiteley.com","Whiteley",30,1.82,0,1582536810],
                      [2,"Jones.com","Jones",44,1.74,0,1582812800],
                      [3,"Simpson@example.com","Simpson",69,1.93,0,1583570630],
                      [4,"Brown@example.com","Brown",15,1.89,0,1590383895]
                  ]
                },
                {
                  name: "messages",
                  schema: [
                    {column:"id", value: "INTEGER PRIMARY KEY NOT NULL"},
                    {column:"userid", value: "INTEGER"},
                    {column:"title", value:"TEXT NOT NULL"},
                    {column:"body", value:"TEXT NOT NULL"},
                    {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                    {column:"last_modified", value:"INTEGER"},
                    {foreignkey: "userid", value:"REFERENCES users(id) ON DELETE CASCADE"}

                  ],
                  values: [
                      [1,1,"test post 1","content test post 1",0,1587310030],
                      [2,3,"test post 2","content test post 2",0,1590388125]
                  ]
                },
              ]
            };
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(dataToImportV2)});
            if(!result.result) {
              throw new Error("IsJsonValid Version 2 failed");
            }
            // full import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(dataToImportV2)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'full' dataToImportV2 failed");
            // try to reload the full import with the same version number
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(dataToImportV2)});

            if(result.changes.changes != 0 ) throw new Error("ImportFromJson reload 'full' dataToImportV2 failed");

            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-from-json", version: 1});
            // open db testNew
            await jeepSqlite.open({database: "db-from-json"});
            isDBJson = await jeepSqlite.isDBOpen({database: "db-from-json"})
            if (!isDBJson.result) throw new Error("isDBOpen 'db-from-json' Version 2 failed");
            stmt = "SELECT users.name, messages.title FROM users INNER JOIN messages on messages.userid = users.id;";
            ret = await jeepSqlite.query({database: "db-from-json",
                                          statement: stmt});
            if(ret.values.length !== 2 ||
                  (ret.values[0].name !== "Whiteley" ||
                    ret.values[0].title !== "test post 1") ||
                  (ret.values[1].name !== "Simpson" ||
                    ret.values[1].title !== "test post 2")) {
              throw new Error("Query 1 db-from-json V2 failed");
            }
            ret = await jeepSqlite.getVersion({database:"db-from-json"});
            if(ret.version !== 2) {
              throw new Error("GetVersion db-from-json V2 failed");
            }
            await jeepSqlite.closeConnection({database:"db-from-json"});

            const partialImport1 = {
              database : "db-from-json",
              version : 2,
              encrypted : false,
              mode : "partial",
              tables :[
                {
                    name: "users",
                    values: [
                        [5,"Addington.com","Addington",22,1.79,0,1590388335],
                        [6,"Bannister.com","Bannister",59,1.85,0,1590393015],
                        [2,"Jones@example.com","Jones",45,1.77,0,1590393325]

                    ]
                },
              ]
            };
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(partialImport1)});
            if(!result.result) {
              throw new Error("IsJsonValid failed");
            }
            // partial import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(partialImport1)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'partial1' dataToImport failed");


            const partialImport2 = {
              database : "db-from-json",
              version : 2,
              encrypted : false,
              mode : "partial",
              tables :[
                {
                  name: "messages",

                  indexes: [
                    {name: "index_messages_on_title",value: "title"},
                    {name: "index_messages_on_last_modified",value: "last_modified DESC"}

                  ],
                  values: [
                      [3,2,"test post 3","content test post 3",0,1590396146],
                      [4,1,"test post 4","content test post 4",0,1590396288]
                  ]
                }
              ]
            };
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(partialImport2)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'partial2' dataToImport failed");

            const partialImport3 = {
              database : "db-from-json",
              version : 2,
              encrypted : false,
              mode : "partial",
              tables :[
                {
                  name: "test113",
                  schema: [
                    {column:"id", value: "TEXT PRIMARY KEY NOT NULL"},
                    {column:"name", value:"TEXT UNIQUE NOT NULL"},
                    {column:"code", value:"TEXT"},
                    {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                    {column:"last_modified", value:"INTEGER"}
                  ],
                  indexes: [
                    {name: "index_test113_on_title",value: "name"},
                    {name: "index_test113_on_last_modified",value: "last_modified DESC"}

                  ],
                  values: [
                      ["ef5c57d5-b885-49a9-9c4d-8b340e4abdbc","valve","BV50",0,1590396146],
                      ["bced3262-5d42-470a-9585-d3fd12c45452","pipe","PIPE100",0,1590396288],
                      ["ef5c57d5-b885-49a9-9c4d-8b340e4abdbc","valve","BV100",0,1590396300],
                  ]
                }
              ]
            };
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(partialImport3)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'partial3' dataToImport failed");

            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-from-json", version: 1});
            // open db db-from-json
            await jeepSqlite.open({database: "db-from-json"});
            // Select all users
            ret = await jeepSqlite.query({database: "db-from-json",
                                          statement: "SELECT * FROM users;"});
            if(ret.values.length !== 6 ||
                  ret.values[0].name !== "Whiteley" ||
                  ret.values[1].name !== "Jones" ||
                  ret.values[2].name !== "Simpson" ||
                  ret.values[3].name !== "Brown" ||
                  ret.values[4].name !== "Addington" ||
                  ret.values[5].name !== "Bannister" ) {
              throw new Error("Query 2 db-from-json Users failed");
            }

            // Select all messages
            ret = await jeepSqlite.query({database: "db-from-json",
                                          statement: "SELECT * FROM messages;"});
            if(ret.values.length !== 4 ||
                  ret.values[0].title !== "test post 1" ||
                  ret.values[1].title !== "test post 2" ||
                  ret.values[2].title !== "test post 3" ||
                  ret.values[3].title !== "test post 4" ) {
              throw new Error("Query 3 db-from-json Messages failed");
            }

            // *** test Export to Json
            // test full export
            let jsonObj = await jeepSqlite.exportToJson({database: "db-from-json",jsonexportmode: 'full'});
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
            if(!result.result) {
              throw new Error("IsJsonValid 'full' export failed");
            }
            //test partial export
            syncDate = "2020-05-20T18:40:00.000Z";
            await jeepSqlite.setSyncDate({database: "db-from-json", syncdate: syncDate});
            jsonObj = await jeepSqlite.exportToJson({database: "db-from-json",jsonexportmode: 'partial'});
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
            if(!result.result) {
              throw new Error("IsJsonValid 'partial' export failed");
            }
            if(jsonObj.export.tables.length != 3 || jsonObj.export.tables[0].name != 'users'
                || jsonObj.export.tables[1].name != 'messages'
                || jsonObj.export.tables[2].name != 'test113'
                || jsonObj.export.tables[0].values.length != 4
                || jsonObj.export.tables[1].values.length != 3
                || jsonObj.export.tables[2].values.length != 2) {
              throw new Error("IsJsonValid 'partial' export failed: No 4 tables");
            }
            ret = await jeepSqlite.isDBExists({database:"db-from-json"});
            if (ret.result) {
              await jeepSqlite.deleteDatabase({database:"db-from-json"});
            }
            await jeepSqlite.closeConnection({database:"testNew"});
            await jeepSqlite.closeConnection({database:"testSet"});
            await jeepSqlite.closeConnection({database:"db-from-json"});

            // *** test copy from asset ***

            await jeepSqlite.copyFromAssets({overwrite: true});
            // create connection to myDB
            await jeepSqlite.createConnection({database:"myDB",version: 1});
            // open db myDB
            await jeepSqlite.open({database: "myDB"});
            // Select all tables,
            ret = await jeepSqlite.getTableList({database: "myDB"});
            if(ret.values.length !== 2 ||
              !ret.values.includes("users") ||
              !ret.values.includes("messages")
            ) {
              throw new Error("GetTableList MyDB Tables failed");
            }

            // Select all users
            ret = await jeepSqlite.query({database: "myDB",
                                          statement: "SELECT * FROM users;"});
            if(ret.values.length != 7 ||
                ret.values[0].name !== "Whiteley" ||
                ret.values[1].name !== "Jones" ||
                ret.values[2].name !== "Simpson" ||
                ret.values[3].name !== "Brown" ||
                ret.values[4].name !== "Jackson" ||
                ret.values[5].name !== "Kennedy" ||
                ret.values[6].name !== "Bush"
            ) {
              throw new Error("Query MyDB Users failed");
            }
            await jeepSqlite.closeConnection({database:"myDB"});
            // create connection to dbForCopy
            await jeepSqlite.createConnection({database:"dbForCopy",version: 1});
            // open db myDB
            await jeepSqlite.open({database: "dbForCopy"});
            // Select all users
            ret = await jeepSqlite.query({database: "dbForCopy",
                                          statement: "SELECT * FROM areas;"});
            if(ret.values.length != 3 ||
                ret.values[0].name !== "Access road" ||
                ret.values[1].name !== "Accessway" ||
                ret.values[2].name !== "Air handling system"              ) {
              throw new Error("Query dbForCopy Areas failed");
            }
            await jeepSqlite.closeConnection({database:"dbForCopy"});


            // check if a database is in the store
            ret = await jeepSqlite.isDatabase({database: "testNew"});
            if(!ret.result) {
              throw new Error("IsDatabase 'testNew' failed");
            }
            ret = await jeepSqlite.isDatabase({database: "testNew1"});
            if(ret.result) {
              throw new Error("IsDatabase 'testNew1' failed");
            }
            // testing import/export JsonSQLite with views
            const dataToImport167 = {
              database: "db-issue167",
              version: 1,
              encrypted: false,
              mode: "full",
              tables: [
                {
                  name: "departments",
                  schema: [
                    {column: "id", value: "INTEGER PRIMARY KEY AUTOINCREMENT" },
                    {column: "name", value: "TEXT NOT NULL" },
                    {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                    {column:"last_modified", value:"INTEGER"}
                  ],
                  indexes: [
                    {name: "index_departments_on_last_modified",value: "last_modified DESC"}
                  ],
                  values: [
                    [1,"Admin",0,1608216034],
                    [2,"Sales",0,1608216034],
                    [3,"Quality Control",0,1608216034],
                    [4,"Marketing",0,1608216034],
                  ]
                },
                {
                  name: "employees",
                  schema: [
                    {column: "id", value: "INTEGER PRIMARY KEY AUTOINCREMENT" },
                    {column: "first_name", value: "TEXT" },
                    {column: "last_name", value: "TEXT" },
                    {column: "salary", value: "NUMERIC" },
                    {column: "dept_id", value: "INTEGER" },
                    {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                    {column: "last_modified", value: "INTEGER"}
                  ],
                  indexes: [
                    {name: "index_departments_on_last_modified",value: "last_modified DESC"}
                  ],
                  values: [
                    [1,"John","Brown",27500,1,0,1608216034],
                    [2,"Sally","Brown",37500,2,0,1608216034],
                    [3,'Vinay','Jariwala', 35100,3,0,1608216034],
                    [4,'Jagruti','Viras', 9500,2,0,1608216034],
                    [5,'Shweta','Rana',12000,3,0,1608216034],
                    [6,'sonal','Menpara', 13000,1,0,1608216034],
                    [7,'Yamini','Patel', 10000,2,0,1608216034],
                    [8,'Khyati','Shah', 50000,3,0,1608216034],
                    [9,'Shwets','Jariwala',19400,2,0,1608216034],
                    [10,'Kirk','Douglas',36400,4,0,1608216034],
                    [11,'Leo','White',45000,4,0,1608216034],
                  ],
                }
              ],
              views: [
                {name: "SalesTeam", value: "SELECT id,first_name,last_name from employees WHERE dept_id IN (SELECT id FROM departments where name='Sales')"},
                {name: "AdminTeam", value: "SELECT id,first_name,last_name from employees WHERE dept_id IN (SELECT id FROM departments where name='Admin')"},
              ]
            }
            const viewsToImport167 = {
              database: "db-issue167",
              version: 1,
              encrypted: false,
              mode: "partial",
              tables: [],
              views: [
                {name: "QualityControlTeam", value: "SELECT id,first_name,last_name from employees WHERE dept_id IN (SELECT id FROM departments where name='Quality Control')"},
                {name: "MarketingTeam", value: "SELECT id,first_name,last_name from employees WHERE dept_id IN (SELECT id FROM departments where name='Marketing')"},
              ]
            }
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(dataToImport167)});
            if(!result.result) {
              throw new Error("IsJsonValid dataToImport167 failed");
            }
            // full import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(dataToImport167)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'full' dataToImport167 failed");
            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-issue167", version: 1});
            // open db db-issue167
            await jeepSqlite.open({database: "db-issue167"});
            isDBJson = await jeepSqlite.isDBOpen({database: "db-issue167"})
            if (!isDBJson.result) throw new Error("isDBOpen 'db-issue167' failed");
            // create synchronization table
            ret = await jeepSqlite.createSyncTable({database: "db-issue167"});
            if (result.changes.changes < 0) throw new Error("CreateSyncTable failed");
            ret = await jeepSqlite.getSyncDate({database: "db-issue167"});
            if(ret.length === 0) throw new Error("GetSyncDate failed");
            // select from view SalesTeam in db
            ret = await jeepSqlite.query({database: "db-issue167",
                                          statement: "SELECT * FROM SalesTeam;"});
            if(ret.values.length !== 4 ||
                    ret.values[0]["last_name"] !== "Brown" ||
                    ret.values[1]["last_name"] !== "Viras" ||
                    ret.values[2]["last_name"] !== "Patel" ||
                    ret.values[3]["last_name"] !== "Jariwala"  ) {
              throw new Error("Query SalesTeam failed");
            }
            // select from view AdminTeam in db
            ret = await jeepSqlite.query({database: "db-issue167",
                                          statement: "SELECT * FROM AdminTeam;"});
            if(ret.values.length !== 2 ||
                    ret.values[0]["last_name"] !== "Brown" ||
                    ret.values[1]["last_name"] !== "Menpara" ) {
              throw new Error("Query AdminTeam failed");
            }
            // close the connection test-updversion
            await jeepSqlite.closeConnection({database:"db-issue167"});

            // partial import views
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(viewsToImport167)});
            if(!result.result) {
              throw new Error("IsJsonValid viewsToImport167 failed");
            }
            // full import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(viewsToImport167)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'partial' viewsToImport167 failed");
            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-issue167", version: 1});
            // open db testNew
            await jeepSqlite.open({database: "db-issue167"});
            isDBJson = await jeepSqlite.isDBOpen({database: "db-issue167"})
            if (!isDBJson.result) throw new Error("isDBOpen 'db-issue167' failed");
            // select from view QualityControlTeam in db
            ret = await jeepSqlite.query({database: "db-issue167",
                                          statement: "SELECT * FROM QualityControlTeam;"});
            if(ret.values.length !== 3 ||
                    ret.values[0]["last_name"] !== "Jariwala" ||
                    ret.values[1]["last_name"] !== "Rana" ||
                    ret.values[2]["last_name"] !== "Shah" ) {
              throw new Error("Query QualityControlTeam failed");
            }
            // select from view MarketingTeam in db
            ret = await jeepSqlite.query({database: "db-issue167",
                                          statement: "SELECT * FROM MarketingTeam;"});
            if(ret.values.length !== 2 ||
                    ret.values[0]["last_name"] !== "Douglas" ||
                    ret.values[1]["last_name"] !== "White" ) {
              throw new Error("Query MarketingTeam failed");
            }
            jsonObj = await jeepSqlite.exportToJson({database: "db-issue167",jsonexportmode: 'full'});
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
            if(!result.result) {
              throw new Error("IsJsonValid 'full' export db-issue167 failed");
            }
            if(!jsonObj.export.tables || jsonObj.export.tables.length !== 2) {
              throw new Error("JsonObj tables not correct");
            }
            if(!jsonObj.export.views || jsonObj.export.views.length !== 4) {
              throw new Error("JsonObj views not correct");
            }


            ret = await jeepSqlite.getDatabaseList();
            if(ret.values.length != 7) {
              new Error("GetDatabaseList failed");
            }

            // create connection to dbZip2
            await jeepSqlite.createConnection({database:"dbZip2",version: 1});
            // open db myDB
            await jeepSqlite.open({database: "dbZip2"});
            statement = `SELECT name FROM sqlite_master WHERE type='table';`;
            // Select all tables
            ret = await jeepSqlite.getTableList({database: "dbZip2"});
            if(ret.values.length !== 2 ||
                ret.values[0]!== "messages" ||
                ret.values[1] !== "users"
            ) {
              throw new Error("GetTableList MyDB Tables failed");
            }
            // Select all users
            ret = await jeepSqlite.query({database: "dbZip2",
                                          statement: "SELECT * FROM users;"});
            if(ret.values.length != 7 ||
                ret.values[0].name !== "Whiteley" ||
                ret.values[1].name !== "Jones" ||
                ret.values[2].name !== "Simpson" ||
                ret.values[3].name !== "Brown" ||
                ret.values[4].name !== "Jackson" ||
                ret.values[5].name !== "Kennedy" ||
                ret.values[6].name !== "Bush"
            ) {
              throw new Error("Query MyDB Users failed");
            }
            await jeepSqlite.closeConnection({database:"dbZip2"});
            // create connection to dbForCopy
            await jeepSqlite.createConnection({database:"dbZip1",version: 1});
            // open db myDB
            await jeepSqlite.open({database: "dbZip1"});
            // Select all users
            ret = await jeepSqlite.query({database: "dbZip1",
                                          statement: "SELECT * FROM areas;"});
            if(ret.values.length != 3 ||
                ret.values[0].name !== "Access road" ||
                ret.values[1].name !== "Accessway" ||
                ret.values[2].name !== "Air handling system"              ) {
              throw new Error("Query dbZip1 Areas failed");
            }
            await jeepSqlite.closeConnection({database:"dbZip1"});
            const dataToImport231 = {
              database : "db-from-json231",
              version : 1,
              encrypted : false,
              mode : "full",
              tables :[
                {
                  name: "users",
                  schema: [
                      {column:"id", value: "INTEGER PRIMARY KEY NOT NULL"},
                      {column:"email", value:"TEXT UNIQUE NOT NULL"},
                      {column:"name", value:"TEXT"},
                      {column:"age", value:"REAL"},
                      {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                      {column:"last_modified", value:"INTEGER"}
                  ],
                  indexes: [
                      {name: "index_users_on_name",value: "name"},
                      {name: "index_users_on_email_name", value: "email ASC, name", mode: "unique"},
                      {name: "index_users_on_last_modified",value: "last_modified DESC"}
                  ],
                  values: [
                      [1,"Whiteley.com","Whiteley",30.5,0,1608216034],
                      [2,"Jones.com","Jones",44.2,0,1608216034],
                      [3,"Simpson@example.com","Simpson",69,0,1608216034],
                      [4,"Brown@example.com","Brown",15,0,1608216034]
                  ]
                },
                {
                  name: "messages",
                  schema: [
                    {column:"id", value: "INTEGER PRIMARY KEY NOT NULL"},
                    {column:"title", value:"TEXT NOT NULL"},
                    {column:"body", value:"TEXT NOT NULL"},
                    {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                    {column:"last_modified", value:"INTEGER"}
                  ],
                  indexes: [
                      {name: "index_messages_on_last_modified",value: "last_modified DESC"}
                  ],
                  values: [
                      [1,"test post 1","content test post 1",0,1608216034],
                      [2,"test post 2","content test post 2",0,1608216034]
                  ]
                },
              ]
            };
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(dataToImport231)});
            if(!result.result) {
              throw new Error("IsJsonValid231 failed");
            }
            // full import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(dataToImport231)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'full' dataToImport231 failed");
            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-from-json231", version: 1});
            // open db testNew
            await jeepSqlite.open({database: "db-from-json231"});
            isDBJson = await jeepSqlite.isDBOpen({database: "db-from-json231"})
            if (!isDBJson.result) throw new Error("isDBOpen 'db-from-json231' failed");
            // create synchronization table
            ret = await jeepSqlite.createSyncTable({database: "db-from-json231"});
            if (result.changes.changes < 0) throw new Error("CreateSyncTable failed");

            ret = await jeepSqlite.getSyncDate({database: "db-from-json231"});
            if(ret.length === 0) throw new Error("GetSyncDate failed");

            // Select all users
            ret = await jeepSqlite.query({database: "db-from-json231",
                                          statement: "SELECT * FROM users;"});
            if(ret.values.length !== 4 ||
                  ret.values[0].name !== "Whiteley" ||
                  ret.values[1].name !== "Jones" ||
                  ret.values[2].name !== "Simpson" ||
                  ret.values[3].name !== "Brown"  ) {
              throw new Error("Query 1 db-from-json231 Users failed");
            }
            await jeepSqlite.closeConnection({database:"db-from-json231"});

            const partialImport231 = {
              database : "db-from-json231",
              version : 1,
              encrypted : false,
              mode : "partial",
              tables :[
                {
                    name: "users",
                    values: [
                        [5,"Addington.com","Addington",22.7,0,1608217135],
                        [6,"Bannister.com","Bannister",59,0,1608217135],
                        [2,"Jones@example.com","Jones",45,0,1608217135]

                    ]
                },
              ]
            };
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(partialImport231)});
            if(!result.result) {
              throw new Error("IsJsonValid Partial231 failed");
            }
            // partial import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(partialImport231)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'partial231' dataToImport failed");
            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-from-json231", version: 1});
            // open db testNew
            await jeepSqlite.open({database: "db-from-json231"});
            // Select all users
            ret = await jeepSqlite.query({database: "db-from-json231",
                                          statement: "SELECT * FROM users;"});
            if(ret.values.length !== 6 ||
                  ret.values[0].name !== "Whiteley" ||
                  ret.values[1].name !== "Jones" ||
                  ret.values[2].name !== "Simpson" ||
                  ret.values[3].name !== "Brown" ||
                  ret.values[4].name !== "Addington" ||
                  ret.values[5].name !== "Bannister" ) {
              throw new Error("Query 2 db-from-json231 Users failed");
            }
            // *** test Export to Json
            // test full export
            jsonObj = await jeepSqlite.exportToJson({database: "db-from-json231",jsonexportmode: 'full'});
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
            if(!result.result) {
              throw new Error("IsJsonValid231 'full' export failed");
            }
            const exObj = jsonObj.export;
            if(exObj.database !== 'db-from-json231' ||
                    exObj.tables.length !== 2 ||
                    exObj.tables[0].name !== 'users' ||
                    exObj.tables[1].name !== 'messages' ||
                    exObj.tables[0].values.length !== 6 ||
                    exObj.tables[1].values.length !== 2) {
              throw new Error("Export231 'full' export failed");
            }
            exObj.overwrite = true;
            // full import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(exObj)});
            console.log(`re-import ovewrite ${exObj.overwrite} ${JSON.stringify(result)}`);
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'full' dataToImport231 failed");
            stmt = `
              DROP TABLE IF EXISTS users;
              DROP TABLE IF EXISTS messages;
            `
            await jeepSqlite.execute({database:"db-from-json231",statements:stmt});
            tableList = await jeepSqlite.getTableList({database:"db-from-json231"});
            if (tableList.values.length != 0) {
              throw new Error("Export231 drop tables failed");
            }
            await jeepSqlite.closeConnection({database:"db-from-json231"});

            // *** test Import from Json
            const dataToImportFull71 = {
              database : 'db-from-json71',
              version : 1,
              encrypted : false,
              mode : 'full',
              tables :[
                  {
                      name: 'company',
                      schema: [
                          {column:'id', value: 'INTEGER'},
                          {column:'name', value:'VARCHAR(25) NOT NULL'},
                          {column:'age', value:'INT NOT NULL'},
                          {column:'country', value:'CHARACTER(20)'},
                          {column:'salary', value:'DECIMAL(10,3)'},
                          {column:'manager', value:'BOOLEAN DEFAULT 0 CHECK (manager IN (0, 1))'},
                          {column:"sql_deleted", value:"BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1))"},
                          {column:'last_modified', value:'INTEGER'},
                          {constraint:'PK_name_country', value:'PRIMARY KEY (name,country)'}
                      ],
                      values: [
                          [1,'Jones',55,'Australia',1250,1,0,1608216034],
                          [2,'Lawson',32,'Ireland',2345.60,0,0,1608216034],
                          [3,'Bush',44,'USA',1850.10,0,0,1608216034],
                      ]
                  },
              ]
            };
            const dataToImportPartial71 = {
              database : 'db-from-json71',
              version : 1,
              encrypted : false,
              mode : 'partial',
              tables :[
                  {
                      name: 'company',
                      values: [
                          [4,'Addington',56,'South Africa',4500,1,0,1608218521],
                          [5,'Bannister',37,'Scotland',2600,0,0,1608218521],
                          [2,'Lawson',32,'Ireland',3000.0,0,0,1608218521],
                          [1,'Jones',55,'Australia',1250,1,0,1608216034],
                      ]
                  },
              ]
            };
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(dataToImportFull71)});
            if(!result.result) {
              throw new Error("IsJsonValid dataToImportFull71 failed");
            }
            // full import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(dataToImportFull71)});
            if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'full' dataToImportFull71 failed");
            // *** test Export to JSON
            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-from-json71", version: 1});
            // open db db-from-json71
            await jeepSqlite.open({database: "db-from-json71"});
            // create synchronization table
            ret = await jeepSqlite.createSyncTable({database: "db-from-json71"});
            if (result.changes.changes < 0) throw new Error("CreateSyncTable for db-from-json71 failed");
            ret = await jeepSqlite.getSyncDate({database: "db-from-json71"});
            if(ret.length === 0) throw new Error("GetSyncDate  for db-from-json71 failed");

            // test full export
            jsonObj = await jeepSqlite.exportToJson({database: "db-from-json71",jsonexportmode: 'full'});
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
            if(!result.result) {
              throw new Error("IsJsonValid 'full' export 1 failed");
            }
            await jeepSqlite.closeConnection({database:"db-from-json71"});

            // *** Test Partial Import
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(dataToImportPartial71)});
            if(!result.result) {
              throw new Error("IsJsonValid dataToImportPartial71 failed");
            }
            // partial import
            result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(dataToImportPartial71)});
            if(result.changes.changes !== 3 ) throw new Error("ImportFromJson 'partial' dataToImportPartial71 failed");

            // *** test Export to Json
            await jeepSqlite.createConnection({database:"db-from-json71", version: 1});
            // open db db-from-json71
            await jeepSqlite.open({database: "db-from-json71"});
            // test full export
            jsonObj = await jeepSqlite.exportToJson({database: "db-from-json71",jsonexportmode: 'full'});
            // test Json object validity
            result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
            if(!result.result) {
              throw new Error("IsJsonValid 'full' export 2 failed");
            }
            const company = jsonObj.export.tables[0];
            if(company.values[0][4] !== 1250 ||
              company.values[1][4] !== 3000.0 ||
              company.values[2][4] !== 1850.1 ||
              company.values[3][4] !== 4500.0 ||
              company.values[4][4] !== 2600.0 ) {
              throw new Error("Export2 'full' Company salaries failed");
            }
            ret = await jeepSqlite.isDBExists({database:"db-from-json71"});
            if (ret.result) {
              await jeepSqlite.deleteDatabase({database:"db-from-json71"});
            }
            await jeepSqlite.closeConnection({database:"db-from-json71"});

            // test issue #448
            // create the connection to the database
            await jeepSqlite.createConnection({database:"db-issue448", version: 1});
            // open db db-from-json71
            await jeepSqlite.open({database: "db-issue448"});
            const isDB448 = await jeepSqlite.isDBOpen({database: "db-issue448"})
            if(!isDB448) {
              throw new Error("Issue448 open DB failed");
            }
            let sql448 = `
              CREATE VIRTUAL TABLE if not exists docToolTextSearch USING fts3(body, id, page);
              INSERT INTO docToolTextSearch (body,id,page) VALUES('FLIGHT MANUAL EC 135 T1 CDS   Emergency and Malfunction Procedures   CAUTION INDICATIONS   ENG MANUAL   or   SYSTEM I   SYSTEM II   Conditions/Indications   Engine MANUAL mode has been selected by setting ENG MODE SEL sw from NORM to   MAN   NOTE    If ENG MANUAL comes together with TWIST GRIP refer to TWIST GRIP cau-   tion indication   Following functions of the respective engine are inoperative       automatic acceleration deceleration during power collective changes   N   1    limiter   NORM start is impossible   Procedure   WARNING    OPERATE THE TWIST GRIP WITH GREAT CARE AND AVOID QUICK TWIST   GRIP ROTATIONS   HOLD MIN 10 TORQUE ON THE NORMAL ENGINE TO MAINTAIN   AUTOMATIC CONTROL OF N   RO      The ENG MANUAL mode may be used for training of the FADEC FAIL procedure   After training is completed return to NORM mode   Respective ENG MODE SEL selector sw   Respective TWIST GRIP   ENG MANUAL caution   TWIST GRIP caution   Wait 10 sec before any power variation   Correct operation in NORM mode   NORM   Turn gradually to NEUTRAL   position   Check off   Verify by small collective   movements   3 - 18   APPROVED   Rev 33   ', '5983270909465803','120');
            `;

            ret = await jeepSqlite.execute({database: "db-issue448", statements: sql448});
            console.log(`Issue448 execute ret: ${JSON.stringify(ret)}`)
            sql448 = `
              CREATE VIRTUAL TABLE if not exists docToolTextSearch USING fts3(body, id, page);
              INSERT INTO docToolTextSearch (body,id,page) VALUES('FLIGHT MANUAL EC 135 T1 CDS   Emergency and Malfunction Procedures   CAUTION INDICATIONS   ENG MANUAL   or   SYSTEM I   SYSTEM II   Conditions/Indications   Engine MANUAL mode has been selected by setting ENG MODE SEL sw from NORM to   MAN   NOTE    If ENG MANUAL comes together with TWIST GRIP refer to TWIST GRIP cau-   tion indication   Following functions of the respective engine are inoperative       automatic acceleration deceleration during power collective changes   N   1    limiter   NORM start is impossible   Procedure   WARNING    OPERATE THE TWIST GRIP WITH GREAT CARE AND AVOID QUICK TWIST   GRIP ROTATIONS   HOLD MIN 10 TORQUE ON THE NORMAL ENGINE TO MAINTAIN   AUTOMATIC CONTROL OF N   RO      The ENG MANUAL mode may be used for training of the FADEC FAIL procedure   After training is completed return to NORM mode   Respective ENG MODE SEL selector sw   Respective TWIST GRIP   ENG MANUAL caution   TWIST GRIP caution   Wait 10 sec before any power variation   Correct operation in NORM mode   NORM   Turn gradually to NEUTRAL   position   Check off   Verify by small collective   movements   3 - 18   APPROVED   Rev 33   ', '5983270909465803','120');
            `;
            const batch = [
              { statement: "DROP TABLE docToolTextSearch;",
                values: []},
              { statement: "CREATE VIRTUAL TABLE if not exists docToolTextSearch USING fts3(body, id, page);",
                values: []},
              { statement: "INSERT INTO docToolTextSearch (body,id,page) VALUES (?,?,?);",
                values:['FLIGHT MANUAL EC 135 T1 CDS   Emergency and Malfunction Procedures   CAUTION INDICATIONS   ENG MANUAL   or   SYSTEM I   SYSTEM II   Conditions/Indications   Engine MANUAL mode has been selected by setting ENG MODE SEL sw from NORM to   MAN   NOTE    If ENG MANUAL comes together with TWIST GRIP refer to TWIST GRIP cau-   tion indication   Following functions of the respective engine are inoperative       automatic acceleration deceleration during power collective changes   N   1    limiter   NORM start is impossible   Procedure   WARNING    OPERATE THE TWIST GRIP WITH GREAT CARE AND AVOID QUICK TWIST   GRIP ROTATIONS   HOLD MIN 10 TORQUE ON THE NORMAL ENGINE TO MAINTAIN   AUTOMATIC CONTROL OF N   RO      The ENG MANUAL mode may be used for training of the FADEC FAIL procedure   After training is completed return to NORM mode   Respective ENG MODE SEL selector sw   Respective TWIST GRIP   ENG MANUAL caution   TWIST GRIP caution   Wait 10 sec before any power variation   Correct operation in NORM mode   NORM   Turn gradually to NEUTRAL   position   Check off   Verify by small collective   movements   3 - 18   APPROVED   Rev 33   ', '5983270909465803','120']
              },
            ];
            ret = await jeepSqlite.executeSet({database: "db-issue448", set: batch});
            console.log(`Issue448 executeSet ret: ${JSON.stringify(ret)}`)


            console.log("db tests were successful");
            messageEl.innerHTML = 'db tests were successful';
        } catch (err) {
          console.log(`Error: ${err}`);
          messageEl.innerHTML = `Error: ${err}`;
        }
    } else {
      console.log("Error: Store creation failed")
      messageEl.innerHTML = "Error: Store creation failed";
    }
  })();
</script>
