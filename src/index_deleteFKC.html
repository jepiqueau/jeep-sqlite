<!DOCTYPE html>
<html dir="ltr" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0" />
    <title>Stencil Component Test Delete</title>

    <script type="module" src="/build/jeep-sqlite.esm.js"></script>
    <script nomodule src="/build/jeep-sqlite.js"></script>
  </head>
  <style>
    /* Navbar container */
    .navbar {
      overflow: hidden;
      background-color: #333;
      font-family: Arial;
    }

    /* Links inside the navbar */
    .navbar a {
      float: left;
      font-size: 16px;
      color: white;
      text-align: center;
      padding: 14px 16px;
      text-decoration: none;
    }

    /* The dropdown container */
    .dropdown {
      float: left;
      overflow: hidden;
    }

    /* Dropdown button */
    .dropdown .dropbtn {
      font-size: 16px;
      border: none;
      outline: none;
      color: white;
      padding: 14px 16px;
      background-color: inherit;
      font-family: inherit; /* Important for vertical align on mobile phones */
      margin: 0; /* Important for vertical align on mobile phones */
    }

    /* Add a red background color to navbar links on hover */
    .navbar a:hover, .dropdown:hover .dropbtn {
      background-color: red;
    }

    /* Dropdown content (hidden by default) */
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #f9f9f9;
      min-width: 160px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1;
    }

    /* Links inside the dropdown */
    .dropdown-content a {
      float: none;
      color: black;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      text-align: left;
    }

    /* Add a grey background color to dropdown links on hover */
    .dropdown-content a:hover {
      background-color: #ddd;
    }

    /* Show the dropdown menu on hover */
    .dropdown:hover .dropdown-content {
      display: block;
    }
    .container {
      margin-left: 25px;
    }
  </style>
  <body>
    <div class="navbar">
      <a href="index.html">Home</a>
      <div class="dropdown">
        <button class="dropbtn">Tests
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="index_delete.html">Delete Tests Page</a>
          <a href="index_deleteFKC.html">Delete FKC Tests Page</a>
          <a href="index_page1_issue11.html">Page 1 Issue11 Tests Page</a>
          <a href="index_page2_issue11.html">Page 2 Issue11 Tests Page</a>
          <a href="index_incremental_upgrade_version.html">New Incremental Upgrade Version</a>
          <a href="index_readonly.html">DB Readonly</a>
          <a href="index_getFromHTTP.html">DB Get FROM HTTP Request</a>
          <a href="index_concurrent.html">DB Concurrent Test</a>
          <a href="index_issue385.html">Issue#385 Test</a>
          <a href="index_getFromLocalDiskToStore.html">DB Get FROM Local Disk to Store</a>
          <a href="index_returning.html">DB Test RETURNING</a>
          <a href="index_issue445.html">DB Test issue445</a>
          <a href="index_transaction.html">DB Test Transactions</a>
        </div>
      </div>
    </div>
    <h1>DeleteFKC Tests Page</h1>
    <div class="container">
      <h2 class="message"></h2>
    </div>
   <jeep-sqlite autoSave="true"></jeep-sqlite>
  </body>
</html>
<script>
  (async () => {
    const messageEl = document.querySelector('.message');
    await customElements.whenDefined('jeep-sqlite');
    const jeepSqlite = document.querySelector('jeep-sqlite');
    // Test button's text
    jeepSqlite.pickText = "Select a Database";

    // Test button's style
    jeepSqlite.buttonOptions = '{"backgroundColor":"#000000", "top":"70%","fontSize":"1.5em"}';

    jeepSqlite.addEventListener('jeepSqliteImportProgress', (event) => {
      console.log(`Import: ${event.detail.progress}`)
    });
    jeepSqlite.addEventListener('jeepSqliteExportProgress', event => {
      console.log(`Export: ${event.detail.progress}`)
    });
    if(await jeepSqlite.isStoreOpen()) {

      const startTest = async (name)  => {
        console.log(`************************************`);
        console.log(`* Starting ${name} *`);
        console.log(`************************************\n\n`);
      };
      const endTest = async(name,msg) => {
        if(msg.length === 0) {
          const message = `* The set of tests ${name} was successful *`
          console.log(`\n${message}\n`);
          messageEl.innerHTML = message;
        } else {
          const message = `${msg}\n* The set of tests ${name} failed *\n`
          console.log(`${message}`);
          messageEl.innerHTML = message;
        }
      }
      const openConnection = async (dbName, encrypted, mode, version, readonly,
                                    isDelete) => {
        try {
          const openMode = readonly ? "RO" : "RW";
          const retCC  = (await jeepSqlite.checkConnectionsConsistency({dbNames:[dbName],openModes:[openMode]})).result;
          const isConn = (await jeepSqlite.isConnection({database: dbName, readonly: readonly})).result;
          if(!retCC || !isConn) {
            console.log('*** create connection \n')
              await jeepSqlite.createConnection({database: dbName, encrypted: encrypted, mode: mode,
                                                 version: version, readonly: readonly});
          }
          if (isDelete && !readonly) {
                await deleteDatabase(dbName);
          }
          await jeepSqlite.open({database: dbName, readonly: readonly});
          return Promise.resolve();
        } catch (err) {
            return Promise.reject(err);
        }
      }
      const deleteDatabase = async (dbName) => {
        try {
            const ret = (await jeepSqlite.isDBExists({database: dbName})).result;
            if(ret) {
                await jeepSqlite.deleteDatabase({database: dbName});
                return Promise.resolve();
            } else {
                return Promise.resolve();
            }
        } catch(err) {
            return Promise.reject(err);
        }
      }
      const showSampleTable = async (message) => {
        try {
          let res = await jeepSqlite.query({database: 'test285',statement: 'SELECT * FROM sample_table'});
          console.log(`**** Show Sample_Table ${message} ****`)
          for( const row of res.values) {
            console.log(`>>> col1: ${row.col1} col2: ${row.col2} col3: ${row.col3} sql_deleted: ${row.sql_deleted}`);
          }
        } catch(err) {
            return Promise.reject(err);
        }
      }
      const showTable1 = async (message) => {
        try {
          let res = await jeepSqlite.query({database: 'test285',statement: 'SELECT * FROM table1'});
          console.log(`\n**** Table1 ${message} ****`)
          for( const row of res.values) {
            console.log(`>>> col1: ${row.col1} col2: ${row.col2} col3: ${row.col3} sql_deleted: ${row.sql_deleted}`);
          }
        } catch(err) {
            return Promise.reject(err);
        }
      }
      const showTable2 = async (message) => {
        try {
          let res = await jeepSqlite.query({database: 'test285',statement: 'SELECT * FROM table2'});
          console.log(`\n**** Table2 ${message} ****`)
          for( const row of res.values) {
            console.log(`>>> id: ${row.id} name: ${row.name} sql_deleted: ${row.sql_deleted}`);
          }
        } catch(err) {
            return Promise.reject(err);
        }
      }
      const showTable3 = async (message) => {
        try {
          let res = await jeepSqlite.query({database: 'test285',statement: 'SELECT * FROM table3'});
          console.log(`\n**** Table3 ${message} ****`)
          for( const row of res.values) {
            console.log(`>>> id: ${row.id} name: ${row.name} sql_deleted: ${row.sql_deleted}`);
          }
        } catch(err) {
            return Promise.reject(err);
        }
      }
      const showAlbum = async (message) => {
        try {
          let res = await jeepSqlite.query({database: 'test285',statement: 'SELECT * FROM album'});
          console.log(`\n**** Album ${message} ****`)
          for( const row of res.values) {
            console.log(`>>> album_artist: ${row.album_artist} album_name: ${row.album_name} sql_deleted: ${row.sql_deleted}`);
          }
        } catch(err) {
            return Promise.reject(err);
        }
      }
      const showSong = async (message) => {
        try {
          let res = await jeepSqlite.query({database: 'test285',statement: 'SELECT * FROM song'});
          console.log(`\n**** Song ${message} ****`)
          for( const row of res.values) {
            console.log(`>>> song_id: ${row.song_id} song_artist: ${row.song_artist} song_album: ${row.song_album} sql_deleted: ${row.sql_deleted}`);
          }
        } catch(err) {
            return Promise.reject(err);
        }
      }

      const createSyncTable = async(dbName) => {
        try {
            // create synchronization table
            let res = await jeepSqlite.createSyncTable({database: dbName});
            if (res.changes.changes < 0) {
                const msg = `createSyncTable ${dbName} changes < 0 `;
                return Promise.reject(`Error: ${msg}`);
            }
            console.log(`> createSyncTable ${dbName} successful\n`);
            // get the synchronization date
            res = await jeepSqlite.getSyncDate({database: dbName});
            if(res.syncDate === 0) {
                const msg = `getSyncDate ${dbName} return 0 `;
                return Promise.reject(`Error: ${msg}`);
            }
            const msg = `> getSyncDate ${dbName} successful\n`;
            console.log(msg);

            // save the db to store
            await jeepSqlite.saveToStore({database: dbName});
            return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            return Promise.reject(`Error: ${msg}`);
        }
      }
      const localSynchronization = async (dbName) => {
        try {
          // set the synchronization date
          await jeepSqlite.setSyncDate({database: dbName, syncdate: (new Date()).toISOString()});
          // remove all rows having sql_deleted = 1
          await jeepSqlite.deleteExportedRows({database: dbName});
          return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            return Promise.reject(`Error: ${msg}`);
        }
      }
      const delay = async (delay, message) => {
        return new Promise (resolve => {
          setTimeout(() => {
            const s = "*".repeat(message.length)
            console.log(`*****************${s}`);
            console.log(`Simulate a delay ${message}`);
            console.log(`*****************${s}`);
            resolve();
          }, delay * 1000);
        });
      }

      // ********************************
      // *** test issue #285 ***
      // ********************************

      const createSchema = `
        CREATE TABLE IF NOT EXISTS sample_table (
            col1 INTEGER NOT NULL,
            col2 TEXT NOT NULL,
            col3 INTEGER NOT NULL,
            col4 TEXT,
            sql_deleted BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1)),
            last_modified INTEGER DEFAULT (strftime('%s', 'now')),
            PRIMARY KEY (col1,col2)
        );

        CREATE INDEX IF NOT EXISTS sample_table_index_last_modified ON sample_table (last_modified);
        CREATE TRIGGER IF NOT EXISTS sample_table_trigger_last_modified
        AFTER UPDATE ON sample_table
        FOR EACH ROW WHEN NEW.last_modified <= OLD.last_modified
        BEGIN
            UPDATE sample_table SET last_modified = ((strftime('%s', 'now')) + 1) WHERE col1=NEW.col1 AND col2=NEW.col2;
        END;
        PRAGMA user_version = 1;
      `;

      const someData = `
        INSERT INTO sample_table (col1,col2,col3,col4) VALUES (1,'asd',1,'test1');
        INSERT INTO sample_table (col1,col2,col3,col4) VALUES (2,'asd',2,'test2');
        INSERT INTO sample_table (col1,col2,col3,col4) VALUES (2,'asd1',2,'test3');
        INSERT INTO sample_table (col1,col2,col3,col4) VALUES (1,'asd1',3,'test4');
      `;

      const createSchema1 = `
        CREATE TABLE IF NOT EXISTS table1 (
            col1 INTEGER NOT NULL,
            col2 TEXT NOT NULL,
            col3 INTEGER NOT NULL,
            sql_deleted BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1)),
            last_modified INTEGER DEFAULT (strftime('%s', 'now')),
            FOREIGN KEY (col1) REFERENCES table2(id) ON DELETE CASCADE,
            FOREIGN KEY (col2) REFERENCES table3(id) ON DELETE CASCADE,
            PRIMARY KEY (col1,col2)
        );

        CREATE INDEX IF NOT EXISTS table1_index_last_modified ON table1 (last_modified);
        CREATE TRIGGER IF NOT EXISTS table1_trigger_last_modified
        AFTER UPDATE ON table1
        FOR EACH ROW WHEN NEW.last_modified <= OLD.last_modified
        BEGIN
            UPDATE table1 SET last_modified = ((strftime('%s', 'now')) + 1) WHERE col1=NEW.col1 AND col2=NEW.col2;
        END;
        CREATE TABLE IF NOT EXISTS table2 (
            id INTEGER PRIMARY KEY NOT NULL,
            name TEXT NOT NULL,
            sql_deleted BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1)),
            last_modified INTEGER DEFAULT (strftime('%s', 'now'))
        );
        CREATE INDEX IF NOT EXISTS table2_index_last_modified ON table2 (last_modified);
        CREATE TRIGGER IF NOT EXISTS table2_trigger_last_modified
        AFTER UPDATE ON table2
        FOR EACH ROW WHEN NEW.last_modified <= OLD.last_modified
        BEGIN
            UPDATE table2 SET last_modified = ((strftime('%s', 'now')) + 1) WHERE id=NEW.id;
        END;
        CREATE TABLE IF NOT EXISTS table3 (
            id TEXT PRIMARY KEY NOT NULL,
            name TEXT NOT NULL,
            sql_deleted BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1)),
            last_modified INTEGER DEFAULT (strftime('%s', 'now'))
        );
        CREATE INDEX IF NOT EXISTS table3_index_last_modified ON table3 (last_modified);
        CREATE TRIGGER IF NOT EXISTS table3_trigger_last_modified
        AFTER UPDATE ON table3
        FOR EACH ROW WHEN NEW.last_modified <= OLD.last_modified
        BEGIN
            UPDATE table3 SET last_modified = ((strftime('%s', 'now')) + 1) WHERE id=NEW.id;
        END;

        PRAGMA user_version = 1;
      `;

      const someData1 = `
        INSERT INTO table2 (id,name) VALUES (1,'asdasd1');
        INSERT INTO table2 (id,name) VALUES (2,'asdasd2');
        INSERT INTO table2 (id,name) VALUES (3,'asdasd3');
        INSERT INTO table2 (id,name) VALUES (4,'asdasd4');
        INSERT INTO table2 (id,name) VALUES (5,'asdasd5');
        INSERT INTO table2 (id,name) VALUES (6,'asdasd6');
        INSERT INTO table2 (id,name) VALUES (7,'asdasd7');
        INSERT INTO table3 (id,name) VALUES ('ef5c57d5-b885-49a9-9c4d-8b340e4abdbc','bsdbsd1');
        INSERT INTO table3 (id,name) VALUES ('bced3262-5d42-470a-9585-d3fd12c45452','bsdbsd2');
        INSERT INTO table3 (id,name) VALUES ('cbed3263-5d43-480b-9585-k3fd12c53491','bsdbsd3');
        INSERT INTO table3 (id,name) VALUES ('600ead3b-e7df-4e63-9f8d-7c82b5cfac42','bsdbsd4');
        INSERT INTO table3 (id,name) VALUES ('7e2e6a24-51bc-4422-b428-4def4fbfc436','bsdbsd5');
        INSERT INTO table3 (id,name) VALUES ('cf77056c-a7fe-4e2d-924d-f2d8a5b21148','bsdbsd6');
        INSERT INTO table3 (id,name) VALUES ('d9fda8de-65f8-4a72-a6c1-05e8f5490e6a','bsdbsd7');
        INSERT INTO table3 (id,name) VALUES ('2210add3-15c1-42a7-b027-6e12d960fb9b','bsdbsd8');
        INSERT INTO table1 (col1,col2,col3) VALUES (1,'ef5c57d5-b885-49a9-9c4d-8b340e4abdbc',1);
        INSERT INTO table1 (col1,col2,col3) VALUES (2,'ef5c57d5-b885-49a9-9c4d-8b340e4abdbc',2);
        INSERT INTO table1 (col1,col2,col3) VALUES (2,'bced3262-5d42-470a-9585-d3fd12c45452',2);
        INSERT INTO table1 (col1,col2,col3) VALUES (1,'bced3262-5d42-470a-9585-d3fd12c45452',3);
        INSERT INTO table1 (col1,col2,col3) VALUES (3,'cf77056c-a7fe-4e2d-924d-f2d8a5b21148',3);
        INSERT INTO table1 (col1,col2,col3) VALUES (4,'600ead3b-e7df-4e63-9f8d-7c82b5cfac42',5);
        INSERT INTO table1 (col1,col2,col3) VALUES (5,'7e2e6a24-51bc-4422-b428-4def4fbfc436',4);
        INSERT INTO table1 (col1,col2,col3) VALUES (6,'d9fda8de-65f8-4a72-a6c1-05e8f5490e6a',6);
        INSERT INTO table1 (col1,col2,col3) VALUES (6,'7e2e6a24-51bc-4422-b428-4def4fbfc436',6);
        INSERT INTO table1 (col1,col2,col3) VALUES (7,'2210add3-15c1-42a7-b027-6e12d960fb9b',7);
        INSERT INTO table1 (col1,col2,col3) VALUES (7,'7e2e6a24-51bc-4422-b428-4def4fbfc436',4);
      `;

      const createSchema2 = `
      CREATE TABLE IF NOT EXISTS album (
          album_artist TEXT NOT NULL,
          album_name TEXT NOT NULL,
          album_date TEXT,
          sql_deleted BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1)),
          last_modified INTEGER DEFAULT (strftime('%s', 'now')),
          PRIMARY KEY (album_artist, album_name)
      );

      CREATE INDEX IF NOT EXISTS album_index_last_modified ON album (last_modified);
      CREATE TRIGGER IF NOT EXISTS album_trigger_last_modified
      AFTER UPDATE ON album
      FOR EACH ROW WHEN NEW.last_modified <= OLD.last_modified
      BEGIN
          UPDATE album SET last_modified = ((strftime('%s', 'now')) + 1) WHERE album_artist=NEW.album_artist AND album_name=NEW.album_name;
      END;
      CREATE TABLE IF NOT EXISTS song (
        song_id INTEGER PRIMARY KEY NOT NULL,
        song_artist TEXT NOT NULL,
        song_album TEXT NOT NULL,
        song_name TEXT NOT NULL,
        sql_deleted BOOLEAN DEFAULT 0 CHECK (sql_deleted IN (0, 1)),
        last_modified INTEGER DEFAULT (strftime('%s', 'now')),
        FOREIGN KEY (song_artist, song_album) REFERENCES album(album_artist,album_name) ON DELETE CASCADE
      );
      CREATE INDEX IF NOT EXISTS song_index_last_modified ON song (last_modified);
      CREATE TRIGGER IF NOT EXISTS song_trigger_last_modified
      AFTER UPDATE ON song
      FOR EACH ROW WHEN NEW.last_modified <= OLD.last_modified
      BEGIN
          UPDATE song SET last_modified = ((strftime('%s', 'now')) + 1) WHERE song_id=NEW.song_id;
      END;

      PRAGMA user_version = 1;
      `;
      const someData2 = `
      INSERT INTO album (album_artist,album_name,album_date) VALUES ('The Rolling Stones','Sticky Fingers','1971');
      INSERT INTO album (album_artist,album_name,album_date) VALUES ('The Rolling Stones','Hyde Park Live','2013');
      INSERT INTO album (album_artist,album_name,album_date) VALUES ('The Beatles','Abbey Road','1969');
      INSERT INTO album (album_artist,album_name,album_date) VALUES ('The Beatles','Help!','1965');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (1,'The Rolling Stones','Sticky Fingers','Brown Sugar');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (2,'The Rolling Stones','Sticky Fingers','Sway');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (3,'The Rolling Stones','Sticky Fingers','Wild Horses');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (4,'The Rolling Stones','Sticky Fingers',"Can't You Hear Me Knock");
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (5,'The Rolling Stones','Sticky Fingers','You Gotta Move');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (6,'The Rolling Stones','Sticky Fingers','Bitch');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (7,'The Rolling Stones','Sticky Fingers','I Got The Blues');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (8,'The Rolling Stones','Sticky Fingers','Sister Morphine');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (9,'The Rolling Stones','Hyde Park Live','Start Me Up');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (10,'The Rolling Stones','Hyde Park Live',"It's Only Rock 'n' Roll");
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (11,'The Beatles','Abbey Road','Come Together');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (12,'The Beatles','Abbey Road','Something');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (13,'The Beatles','Abbey Road',"Maxwell's Silver Hammer");
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (14,'The Beatles','Help!','Help!');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (15,'The Beatles','Help!','The Night Before');
      INSERT INTO song (song_id,song_artist,song_album,song_name) VALUES (16,'The Beatles','Help!',"Youâ€™ve Got To Hide Your Love Away");
      `;



      const initializeTest = async() => {
        // Test with composite primary keys
        try {
          // test the plugin with echo
          let res = await jeepSqlite.echo({value:"Hello from echo"});
          if(res.value !== "Hello from echo"){
              const msg = `Error: Echo not returning "Hello from echo"\n`;
              return Promise.reject(msg);
          }
          console.log("> Echo successful\n");
          await openConnection('test285', false,
                                    'no-encryption', 1, false, true);

          console.log("> Open connection 'test285' successful\n");
          // create tables in db
          const isDB = await jeepSqlite.isDBOpen({database: 'test285'});
          if(!isDB) return Promise.reject('Database "test285" not opened')
          let ret = await jeepSqlite.execute({database: 'test285', statements: createSchema});
          console.log(`>>> createSchema ret ${JSON.stringify(ret)}`)
          if (ret.changes.changes < 0) {
              const msg = "Error: Execute createSchema failed";
              return Promise.reject(msg);
          }
          console.log("> Create DB Schema 'test285' successful\n");
          res = await jeepSqlite.getTableList({database: "test285"});
          console.log(`>>> getTableList res ${JSON.stringify(res)}`)
          // Delete sample_table if any
          let stmt = "DELETE FROM sample_table;"
          res = await jeepSqlite.execute({database: 'test285',statements: stmt});
          console.log(`>>> execute DELETE FROM sample_table res: ${JSON.stringify(res)}`);
          // Insert some data
          res = await jeepSqlite.execute({database: 'test285',statements: someData});
          if (res.changes.changes !== 4) {
              const msg = `Execute insert someData changes != 4`;
              return Promise.reject(msg);
          }
          console.log("> Execute insert someData successful\n");

          // save the db to store
          await jeepSqlite.saveToStore({database: 'test285'});
          // Query the sample_table data
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM sample_table"});
          if(res.values.length !== 4 ) {
              const msg = `Query not returning 4 data`;
              return Promise.reject(msg);
          }
          console.log("> Select someData successful\n");

          return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            console.log(`Error: ${msg}`);
            return Promise.reject(msg);
        }
      }
      const deleteTest = async() => {
        try {
            let stmt = "";
            // Delete in an execute statement
            stmt = `
            DELETE FROM sample_table WHERE col1 = 1 AND col2 = 'asd';
            `;
            var res = await jeepSqlite.execute({database: 'test285',statements: stmt});
            console.log(`>>> delete execute res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 1*2) {
                const msg = `execute delete "test285" changes != 2 `;
                return Promise.reject(`Error: ${msg}`);
            }
            console.log("> delete with execute successful\n");

            // Delete in a run statement
            stmt = "DELETE FROM sample_table WHERE col1 = ? AND col2 = ?;";
            res = await jeepSqlite.run({database: "test285",statement: stmt,values: [2,'asd1']});
            console.log(`res.changes.changes: ${res.changes.changes}`)
            if(res.changes.changes != 1*2) {
                const msg = `run delete "test285" changes != 2 `;
                return Promise.reject(`Error: ${msg}`);
            }

            console.log("> delete with run  successful\n");

            // Delete in an executeSet statement
            const deleteSet = [
                {
                    statement: "DELETE FROM sample_table WHERE col1 = ? AND col2 = ?;",
                    values: [
                        [2, 'asd'],
                        [1, 'asd1']
                    ]
                }
            ];
            res = await jeepSqlite.executeSet({database: "test285", set: deleteSet});
            if(res.changes.changes != 2*2) {
                const msg = `executeSet delete "test285" changes != 4 `;
                return Promise.reject(`Error: ${msg}`);
            }

            console.log("> delete with executeSet successful\n");

            // save the db to store
            await jeepSqlite.saveToStore({database: 'test285'});
            return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            return Promise.reject(`Error: ${msg}`);
        }
      }
      const initializeTestFK = async() => {
        // test with Foreign Keys
        try {
          // create tables in db
          let ret = await jeepSqlite.execute({database: 'test285', statements: createSchema1});
          console.log(`>>> createSchema ret ${JSON.stringify(ret)}`)
          if (ret.changes.changes < 0) {
              const msg = "Error: Execute createSchema1 failed";
              return Promise.reject(msg);
          }
          console.log("> Create DB Schema1 'test285' successful\n");
          res = await jeepSqlite.getTableList({database: "test285"});
          console.log(`>>> getTableList res ${JSON.stringify(res)}`)
          // Delete table1, table2 and table3 if any
          let stmt = "DELETE FROM table1;"
          res = await jeepSqlite.execute({database: 'test285',statements: stmt});
          console.log(`>>> execute DELETE FROM table1 res: ${JSON.stringify(res)}`);
          stmt = "DELETE FROM table2;"
          res = await jeepSqlite.execute({database: 'test285',statements: stmt});
          console.log(`>>> execute DELETE FROM table2 res: ${JSON.stringify(res)}`);
          stmt = "DELETE FROM table3;"
          res = await jeepSqlite.execute({database: 'test285',statements: stmt});
          console.log(`>>> execute DELETE FROM table3 res: ${JSON.stringify(res)}`);
          // Insert some data
          res = await jeepSqlite.execute({database: 'test285',statements: someData1});
          if (res.changes.changes !== 26) {
              const msg = `Execute insert someData changes != 26`;
              return Promise.reject(msg);
          }
          console.log("> Execute insert someData1 successful\n");

          // save the db to store
          await jeepSqlite.saveToStore({database: 'test285'});
          // Query the table1
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM table1"});
          if(res.values.length !== 11 ) {
              const msg = `Query not returning 11 data`;
              return Promise.reject(msg);
          }
          // Query the table2
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM table2"});
          if(res.values.length !== 7 ) {
              const msg = `Query not returning 7 data from table2`;
              return Promise.reject(msg);
          }
          // Query the table3
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM table3"});
          if(res.values.length !== 8 ) {
              const msg = `Query not returning 8 data from table3`;
              return Promise.reject(msg);
          }
          console.log("> Select someData successful\n");

          return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            console.log(`Error: ${msg}`);
            return Promise.reject(msg);
        }
      }
      const deleteTestFK = async() => {
        try {
            // ******************
            // DELETE from table1
            // ******************
            let stmt = "";
            // Delete in an execute statement
            stmt = `
            DELETE FROM table1 WHERE col1 = 1 AND col2 = 'ef5c57d5-b885-49a9-9c4d-8b340e4abdbc';
            `;
            var res = await jeepSqlite.execute({database: 'test285',statements: stmt});
            console.log(`>>> delete1 execute res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 1*2) {
                const msg = `execute delete "test285" changes != 2 `;
                return Promise.reject(`Error: ${msg}`);
            }
            console.log("> delete with execute successful\n");

            // Delete in a run statement
            stmt = "DELETE FROM table1 WHERE col1 = ? AND col2 = ?;";
            res = await jeepSqlite.run({database: "test285",statement: stmt,values: [2,'bced3262-5d42-470a-9585-d3fd12c45452']});
            console.log(`>>> delete2 run res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 1*2) {
                const msg = `run delete "test285" changes != 2 `;
                return Promise.reject(`Error: ${msg}`);
            }

            console.log("> delete with run  successful\n");

            // Delete in an executeSet statement
            const deleteSet = [
                {
                    statement: "DELETE FROM table1 WHERE col1 = ? AND col2 = ?;",
                    values: [
                        [2, 'ef5c57d5-b885-49a9-9c4d-8b340e4abdbc'],
                        [1, 'bced3262-5d42-470a-9585-d3fd12c45452']
                    ]
                }
            ];
            res = await jeepSqlite.executeSet({database: "test285", set: deleteSet});
            console.log(`>>> delete executeSet res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 2*2) {
                const msg = `executeSet delete3 "test285" changes != 4 `;
                return Promise.reject(`Error: ${msg}`);
            }

            // ******************
            // DELETE from table2
            // ******************
            stmt = `
            DELETE FROM table2 WHERE id = 6;
            `;
            res = await jeepSqlite.execute({database: 'test285',statements: stmt});
            console.log(`>>> delete1 table2 execute res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 3*2) {
                const msg = `run delete "test285" changes != 6 `;
                return Promise.reject(`Error: ${msg}`);
            }
            // ******************
            // DELETE from table3
            // ******************
            stmt = `
            DELETE FROM table3 WHERE id = '7e2e6a24-51bc-4422-b428-4def4fbfc436';
            `;
            var res = await jeepSqlite.execute({database: 'test285',statements: stmt});
            console.log(`>>> delete1 table3 execute res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 3*2) {
                const msg = `run delete "test285" changes != 6 `;
                return Promise.reject(`Error: ${msg}`);
            }


            console.log("> delete with executeSet successful\n");

            // save the db to store
            await jeepSqlite.saveToStore({database: 'test285'});
            return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            return Promise.reject(`Error: ${msg}`);
        }
      }
      const initializeTestFKCPK = async() => {
        // test with Foreign Keys and Composite Primary Key
        try {
          // create tables in db
          let ret = await jeepSqlite.execute({database: 'test285', statements: createSchema2});
          console.log(`>>> createSchema2 ret ${JSON.stringify(ret)}`)
          if (ret.changes.changes < 0) {
              const msg = "Error: Execute createSchema2 failed";
              return Promise.reject(msg);
          }
          console.log("> Create DB Schema2 'test285' successful\n");
          res = await jeepSqlite.getTableList({database: "test285"});
          console.log(`>>> getTableList res ${JSON.stringify(res)}`)
          // Delete album, song if any
          let stmt = "DELETE FROM album;"
          res = await jeepSqlite.execute({database: 'test285',statements: stmt});
          console.log(`>>> execute DELETE FROM album res: ${JSON.stringify(res)}`);
          stmt = "DELETE FROM song;"
          res = await jeepSqlite.execute({database: 'test285',statements: stmt});
          console.log(`>>> execute DELETE FROM song res: ${JSON.stringify(res)}`);
          // Insert some data
          res = await jeepSqlite.execute({database: 'test285',statements: someData2});
          if (res.changes.changes !== 20) {
              const msg = `Execute insert someData2 changes != 20`;
              return Promise.reject(msg);
          }
          console.log("> Execute insert someData2 successful\n");

          // save the db to store
          await jeepSqlite.saveToStore({database: 'test285'});
          // Query the album
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM album"});
          if(res.values.length !== 4 ) {
              const msg = `Query not returning 4 data`;
              return Promise.reject(msg);
          }
          // Query the song
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM song"});
          if(res.values.length !== 16 ) {
              const msg = `Query not returning 16 data from song`;
              return Promise.reject(msg);
          }
          console.log("> Select someData2 successful\n");

          // *** test Export to Json
          // test full export
          let jsonObj = await jeepSqlite.exportToJson({database: "test285",jsonexportmode: 'full'});
          console.log(`Json Object Exported: ${JSON.stringify(jsonObj.export)} `);
          // test Json object validity
          result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
          if(!result.result) {
            throw new Error("IsJsonValid 'full' export failed");
          }
          // Delete the database to import the exported jsonObj
          await jeepSqlite.deleteDatabase({database: 'test285'});
          await jeepSqlite.closeConnection({database: 'test285'});
          // test Json object validity
          result = await jeepSqlite.isJsonValid({jsonstring: JSON.stringify(jsonObj.export)});
          if(!result.result) {
            throw new Error("IsJsonValid 'full' failed");
          }
          console.log("> IsJsonValid successful\n");
          console.log(`${JSON.stringify(jsonObj.export)}`)
          // full import
          result = await jeepSqlite.importFromJson({jsonstring: JSON.stringify(jsonObj.export)});
          if(result.changes.changes === -1 ) throw new Error("ImportFromJson 'full' jsonObj failed");
          console.log(`>>> result.changes.changes ${result.changes.changes}`);
          console.log("> ImportFromJson successful\n");
          await openConnection('test285', false,
                                    'no-encryption', 1, false, false);
          // save the db to store
          await jeepSqlite.saveToStore({database: 'test285'});
          res = await jeepSqlite.getTableList({database: "test285"});
          console.log(`>>> getTableList res ${JSON.stringify(res)}`)
          // Query the album
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM album"});
          if(res.values.length !== 4 ) {
              const msg = `Query not returning 4 data`;
              return Promise.reject(msg);
          }
          // Query the song
          res = await jeepSqlite.query({database: 'test285',statement: "SELECT * FROM song"});
          if(res.values.length !== 16 ) {
              const msg = `Query not returning 16 data from song`;
              return Promise.reject(msg);
          }
          console.log("> Select from JsonObj successful\n");

          return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            console.log(`Error: ${msg}`);
            return Promise.reject(msg);
        }
      }
      const deleteTestFKCPK = async() => {
        try {
            let stmt = "";
            // Delete in an execute statement
            stmt = `
            DELETE FROM album WHERE album_artist = 'The Beatles' AND album_name = 'Abbey Road';
            `;
            var res = await jeepSqlite.execute({database: 'test285',statements: stmt});
            console.log(`>>> delete execute res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 4*2) {
                const msg = `execute delete "test285" changes != 8 `;
                return Promise.reject(`Error: ${msg}`);
            }
            console.log("> delete with execute successful\n");

            // Delete in a run statement
            stmt = "DELETE FROM album WHERE album_artist = ? AND album_name = ?;";
            res = await jeepSqlite.run({database: "test285",statement: stmt,values: ['The Beatles','Help!']});
            console.log(`>>> delete run res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 4*2) {
                const msg = `run delete "test285" changes != 8 `;
                return Promise.reject(`Error: ${msg}`);
            }

            console.log("> delete with run  successful\n");

            // Delete in an executeSet statement
            const deleteSet = [
                {
                    statement: "DELETE FROM album WHERE album_artist = ? AND album_name = ?;",
                    values: [
                        ['The Rolling Stones','Sticky Fingers'],
                        ['The Rolling Stones','Hyde Park Live']
                    ]
                }
            ];
            res = await jeepSqlite.executeSet({database: "test285", set: deleteSet});
            console.log(`>>> delete executeSet res: ${JSON.stringify(res)}`)
            if(res.changes.changes != 12*2) {
                const msg = `executeSet delete "test285" changes != 24 `;
                return Promise.reject(`Error: ${msg}`);
            }

            console.log("> delete with executeSet successful\n");

            // save the db to store
            await jeepSqlite.saveToStore({database: 'test285'});
            return Promise.resolve();
        } catch (err) {
            let msg = err.message ? err.message : err;
            return Promise.reject(`Error: ${msg}`);
        }
      }

      try {
        var activeTest = 'Test Issue285';
        // test standard SQL statements
        await startTest(activeTest);
        // initialize the database test285 and fill some data
        await initializeTest();
        // create synchronization table
        await createSyncTable('test285');
        // Show the initial sample_table
        await showSampleTable('initial data');
        // test of deleting some data
        await deleteTest();
        await showSampleTable('after first delete');
        // add tables to the database test285 and fill some data
        await initializeTestFK();
        // Show the initial table1
        await showTable1('initial data');
        // Show the initial table2
        await showTable2('initial data');
        // Show the initial table3
        await showTable3('initial data');
        // Delete From Table_1
        await deleteTestFK();
        // Show the after delete table1
        await showTable1('after delete');
        // Show the after delete table2
        await showTable2('after delete');
        // Show the after delete table3
        await showTable3('after delete');
        // add tables to the database test285 and fill some data
        await initializeTestFKCPK();
        // Show the initial album
        await showAlbum('initial data');
        // Show the initial song
        await showSong('initial data');
        await deleteTestFKCPK();
        // Show the after delete album
        await showAlbum('after delete data');
        // Show the after delete song
        await showSong('after delete data');

/*
        // delay before to do an export full
        await delay(2, 'before full export');
        // export full
        await exportFull('testNew');
        // after loading to remote server set local new synchronization date
        await localSynchronization('testNew');
        // Show the final users
        await showUsers('final');
*/
        // Save the database to disk
        await jeepSqlite.saveToLocalDisk({database:'test285'});

        // Close Connection test285
        await jeepSqlite.closeConnection({database: 'test285'});
        let msg = `> closeConnection "test285" successful\n`;
        console.log(msg);
        await endTest(activeTest,'');

      } catch (err) {
        let msg = err.message ? err.message : err;
        console.log(`Error: ${msg}`);
        await endTest(activeTest,msg);
      }

    }
  })();
</script>

